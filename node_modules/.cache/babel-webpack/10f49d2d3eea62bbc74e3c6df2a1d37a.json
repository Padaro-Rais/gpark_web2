{"ast":null,"code":"import { FormArray, FormGroup, Validators } from \"@angular/forms\";\nimport { CustomValidators } from \"../../../../validators/validators\";\nimport { InputTypes } from \"../../core/contracts\";\nimport { MomentUtils } from \"../../../../utils/datetime\";\nimport { observableOf } from \"../../../../rxjs/helpers\";\nimport { tap } from \"rxjs/operators\";\n/**\n * @description Helper class for generating angular reactive form controls with errors validation\n */\n\nexport class ComponentReactiveFormHelpers {\n  /**\n   * Loop through formGroup controls and mark them as touched\n   * @param control [[FormGroup|FormArray]] Reference to component formGroup object\n   */\n  static validateFormGroupFields(control) {\n    Object.keys(control.controls).forEach(field => {\n      if (control.get(field) instanceof FormGroup) {\n        ComponentReactiveFormHelpers.validateFormGroupFields(control.get(field));\n      } else {\n        ComponentReactiveFormHelpers.markControlAsTouched(control.get(field) || undefined, field);\n      }\n    });\n  }\n  /**\n   * Mark control as touched them as touched\n   * @param formGroup [[AbstractControl]] reference to form control\n   */\n\n\n  static markControlAsTouched(control, field) {\n    if (control) {\n      control === null || control === void 0 ? void 0 : control.markAsTouched({\n        onlySelf: true\n      });\n      control === null || control === void 0 ? void 0 : control.markAsDirty({\n        onlySelf: true\n      });\n      control === null || control === void 0 ? void 0 : control.markAsPristine({\n        onlySelf: true\n      });\n    }\n  }\n  /**\n   * @description Clear validators on a control and update it value and validation rules\n   * @param control [[AbstractControl]]\n   */\n\n\n  static clearControlValidators(control) {\n    control === null || control === void 0 ? void 0 : control.clearValidators();\n    control === null || control === void 0 ? void 0 : control.updateValueAndValidity();\n  }\n  /**\n   * @description Clear async validators on a control and update it value and validation rules\n   * @param control [[AbstractControl]]\n   */\n\n\n  static clearAsyncValidators(control) {\n    control === null || control === void 0 ? void 0 : control.clearAsyncValidators();\n    control === null || control === void 0 ? void 0 : control.updateValueAndValidity();\n  }\n  /**\n   * @description Set new validators on a control and update it value and validation rules\n   * @param control [[AbstractControl]]\n   */\n\n\n  static setValidators(control, validators) {\n    control === null || control === void 0 ? void 0 : control.setValidators(validators || null);\n    control === null || control === void 0 ? void 0 : control.updateValueAndValidity();\n  }\n\n}\n/**\n * @description Generate an abstract form control using input configuration\n *\n * @param builder Angular forms reactive formbuilder\n * @param input dynamic input configuration\n */\n\nComponentReactiveFormHelpers.buildFormGroupFromInputConfig = (builder, input) => {\n  const group = builder.group({});\n  input.map(config => {\n    var _a, _b, _c, _d, _e, _f;\n\n    if (config.type !== InputTypes.CHECKBOX_INPUT) {\n      const validators = [config.rules && config.rules.isRequired ? Validators.required : Validators.nullValidator];\n      const asyncValidators = [];\n\n      if (config.type === InputTypes.TEXT_INPUT || config.type === InputTypes.EMAIL_INPUT || config.type === InputTypes.PASSWORD_INPUT) {\n        // Checks if maxlength rule is set to true and apply the rule to the input\n        config.rules && config.rules.maxLength ? validators.push(Validators.maxLength(((_a = config) === null || _a === void 0 ? void 0 : _a.maxLength) ? config.maxLength || Math.pow(2, 31) - 1 : 255)) : // tslint:disable-next-line:no-unused-expression\n        null, // Checks if maxlength rule is set to true and apply the rule to the input\n        config.rules && config.rules.minLength ? validators.push(Validators.minLength(((_b = config) === null || _b === void 0 ? void 0 : _b.minLength) ? config.minLength || 1 : 255)) : // tslint:disable-next-line:no-unused-expression\n        null;\n        config.rules && config.rules.email ? validators.push(Validators.email) : // tslint:disable-next-line:no-unused-expression\n        null;\n        config.rules && config.rules.pattern ? validators.push(Validators.pattern(config.pattern || \"\")) : // tslint:disable-next-line:no-unused-expression\n        null;\n      } // Check for min an max rules on number inputs and apply validation to the input\n\n\n      if (config.type === InputTypes.NUMBER_INPUT) {\n        config.rules && config.rules.min ? validators.push(Validators.min(((_c = config) === null || _c === void 0 ? void 0 : _c.min) ? config.min : -1)) : // tslint:disable-next-line:no-unused-expression\n        null, // Checks if maxlength rule is set to true and apply the rule to the input\n        config.rules && config.rules.max ? validators.push(Validators.max(((_d = config) === null || _d === void 0 ? void 0 : _d.max) ? config.max || Math.pow(2, 31) - 1 : Math.pow(2, 31) - 1)) : // tslint:disable-next-line:no-unused-expression\n        null;\n      } // Validation rules form date input\n\n\n      if (config.type === InputTypes.DATE_INPUT) {\n        config.rules && config.rules.minDate ? validators.push(CustomValidators.minDate(((_e = config) === null || _e === void 0 ? void 0 : _e.minDate) ? MomentUtils.parseDate(config.minDate, undefined, \"YYYY-MM-DD\") : MomentUtils.parseDate())) : // tslint:disable-next-line:no-unused-expression\n        null, // Checks if maxlength rule is set to true and apply the rule to the input\n        config.rules && config.rules.maxDate ? validators.push(CustomValidators.maxDate(((_f = config) === null || _f === void 0 ? void 0 : _f.maxDate) ? MomentUtils.parseDate(config.maxDate, undefined, \"YYYY-MM-DD\") : MomentUtils.parseDate())) : // tslint:disable-next-line:no-unused-expression\n        null;\n      } // Add formControl to the form group with the generated validation rules\n\n\n      const control = builder.control({\n        value: config.value,\n        disabled: config.disabled\n      }, asyncValidators.length > 0 || config.type === InputTypes.DATE_INPUT ? {\n        validators: Validators.compose(validators),\n        updateOn: \"blur\",\n        asyncValidators\n      } : {\n        validators: Validators.compose(validators)\n      });\n      group.addControl(config.formControlName, control // Add other necessary validators\n      );\n    } else {\n      // Build list of checkboxes\n      const array = new FormArray([]);\n      observableOf(config.items).pipe(tap(items => {\n        items.map((it, index) => {\n          // Added validation rule to checkbox array\n          array.push(builder.control(it.checked));\n        });\n      })).subscribe(); // Add FormArray control to the formGroup\n\n      if (config.rules && config.rules.isRequired) {\n        array.setValidators(Validators.required);\n      }\n\n      group.addControl(config.formControlName, array);\n    }\n  });\n  return group;\n};\n/**\n * @description Build an angular form group from a dynamic form instance\n *\n * @param builder\n * @param form\n */\n\n\nexport const createAngularAbstractControl = (builder, form) => {\n  return form ? ComponentReactiveFormHelpers.buildFormGroupFromInputConfig(builder, [...(form === null || form === void 0 ? void 0 : form.controlConfigs)]) : undefined;\n};","map":{"version":3,"sources":["/Users/liksoft/PROJETS/FRONT/ANGULAR/Archive_Lik_Angular/src/app/core/components/dynamic-inputs/angular/helpers/reactive-form-helpers.ts"],"names":["FormArray","FormGroup","Validators","CustomValidators","InputTypes","MomentUtils","observableOf","tap","ComponentReactiveFormHelpers","validateFormGroupFields","control","Object","keys","controls","forEach","field","get","markControlAsTouched","undefined","markAsTouched","onlySelf","markAsDirty","markAsPristine","clearControlValidators","clearValidators","updateValueAndValidity","clearAsyncValidators","setValidators","validators","buildFormGroupFromInputConfig","builder","input","group","map","config","_a","_b","_c","_d","_e","_f","type","CHECKBOX_INPUT","rules","isRequired","required","nullValidator","asyncValidators","TEXT_INPUT","EMAIL_INPUT","PASSWORD_INPUT","maxLength","push","Math","pow","minLength","email","pattern","NUMBER_INPUT","min","max","DATE_INPUT","minDate","parseDate","maxDate","value","disabled","length","compose","updateOn","addControl","formControlName","array","items","pipe","it","index","checked","subscribe","createAngularAbstractControl","form","controlConfigs"],"mappings":"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","sourcesContent":["import { FormArray, FormGroup, Validators, } from \"@angular/forms\";\nimport { CustomValidators } from \"../../../../validators/validators\";\nimport { InputTypes, } from \"../../core/contracts\";\nimport { MomentUtils } from \"../../../../utils/datetime\";\nimport { observableOf } from \"../../../../rxjs/helpers\";\nimport { tap } from \"rxjs/operators\";\n/**\n * @description Helper class for generating angular reactive form controls with errors validation\n */\nexport class ComponentReactiveFormHelpers {\n    /**\n     * Loop through formGroup controls and mark them as touched\n     * @param control [[FormGroup|FormArray]] Reference to component formGroup object\n     */\n    static validateFormGroupFields(control) {\n        Object.keys(control.controls).forEach((field) => {\n            if (control.get(field) instanceof FormGroup) {\n                ComponentReactiveFormHelpers.validateFormGroupFields(control.get(field));\n            }\n            else {\n                ComponentReactiveFormHelpers.markControlAsTouched(control.get(field) || undefined, field);\n            }\n        });\n    }\n    /**\n     * Mark control as touched them as touched\n     * @param formGroup [[AbstractControl]] reference to form control\n     */\n    static markControlAsTouched(control, field) {\n        if (control) {\n            control === null || control === void 0 ? void 0 : control.markAsTouched({ onlySelf: true });\n            control === null || control === void 0 ? void 0 : control.markAsDirty({ onlySelf: true });\n            control === null || control === void 0 ? void 0 : control.markAsPristine({ onlySelf: true });\n        }\n    }\n    /**\n     * @description Clear validators on a control and update it value and validation rules\n     * @param control [[AbstractControl]]\n     */\n    static clearControlValidators(control) {\n        control === null || control === void 0 ? void 0 : control.clearValidators();\n        control === null || control === void 0 ? void 0 : control.updateValueAndValidity();\n    }\n    /**\n     * @description Clear async validators on a control and update it value and validation rules\n     * @param control [[AbstractControl]]\n     */\n    static clearAsyncValidators(control) {\n        control === null || control === void 0 ? void 0 : control.clearAsyncValidators();\n        control === null || control === void 0 ? void 0 : control.updateValueAndValidity();\n    }\n    /**\n     * @description Set new validators on a control and update it value and validation rules\n     * @param control [[AbstractControl]]\n     */\n    static setValidators(control, validators) {\n        control === null || control === void 0 ? void 0 : control.setValidators(validators || null);\n        control === null || control === void 0 ? void 0 : control.updateValueAndValidity();\n    }\n}\n/**\n * @description Generate an abstract form control using input configuration\n *\n * @param builder Angular forms reactive formbuilder\n * @param input dynamic input configuration\n */\nComponentReactiveFormHelpers.buildFormGroupFromInputConfig = (builder, input) => {\n    const group = builder.group({});\n    input.map((config) => {\n        var _a, _b, _c, _d, _e, _f;\n        if (config.type !== InputTypes.CHECKBOX_INPUT) {\n            const validators = [\n                config.rules && config.rules.isRequired\n                    ? Validators.required\n                    : Validators.nullValidator,\n            ];\n            const asyncValidators = [];\n            if (config.type === InputTypes.TEXT_INPUT ||\n                config.type === InputTypes.EMAIL_INPUT ||\n                config.type === InputTypes.PASSWORD_INPUT) {\n                // Checks if maxlength rule is set to true and apply the rule to the input\n                config.rules && config.rules.maxLength\n                    ? validators.push(Validators.maxLength(((_a = config) === null || _a === void 0 ? void 0 : _a.maxLength)\n                        ? config.maxLength || Math.pow(2, 31) - 1\n                        : 255))\n                    : // tslint:disable-next-line:no-unused-expression\n                        null,\n                    // Checks if maxlength rule is set to true and apply the rule to the input\n                    config.rules && config.rules.minLength\n                        ? validators.push(Validators.minLength(((_b = config) === null || _b === void 0 ? void 0 : _b.minLength)\n                            ? config.minLength || 1\n                            : 255))\n                        : // tslint:disable-next-line:no-unused-expression\n                            null;\n                config.rules && config.rules.email\n                    ? validators.push(Validators.email)\n                    : // tslint:disable-next-line:no-unused-expression\n                        null;\n                config.rules && config.rules.pattern\n                    ? validators.push(Validators.pattern(config.pattern || \"\"))\n                    : // tslint:disable-next-line:no-unused-expression\n                        null;\n            }\n            // Check for min an max rules on number inputs and apply validation to the input\n            if (config.type === InputTypes.NUMBER_INPUT) {\n                config.rules && config.rules.min\n                    ? validators.push(Validators.min(((_c = config) === null || _c === void 0 ? void 0 : _c.min)\n                        ? config.min\n                        : -1))\n                    : // tslint:disable-next-line:no-unused-expression\n                        null,\n                    // Checks if maxlength rule is set to true and apply the rule to the input\n                    config.rules && config.rules.max\n                        ? validators.push(Validators.max(((_d = config) === null || _d === void 0 ? void 0 : _d.max)\n                            ? config.max || Math.pow(2, 31) - 1\n                            : Math.pow(2, 31) - 1))\n                        : // tslint:disable-next-line:no-unused-expression\n                            null;\n            }\n            // Validation rules form date input\n            if (config.type === InputTypes.DATE_INPUT) {\n                config.rules && config.rules.minDate\n                    ? validators.push(CustomValidators.minDate(((_e = config) === null || _e === void 0 ? void 0 : _e.minDate)\n                        ? MomentUtils.parseDate(config.minDate, undefined, \"YYYY-MM-DD\")\n                        : MomentUtils.parseDate()))\n                    : // tslint:disable-next-line:no-unused-expression\n                        null,\n                    // Checks if maxlength rule is set to true and apply the rule to the input\n                    config.rules && config.rules.maxDate\n                        ? validators.push(CustomValidators.maxDate(((_f = config) === null || _f === void 0 ? void 0 : _f.maxDate)\n                            ? MomentUtils.parseDate(config.maxDate, undefined, \"YYYY-MM-DD\")\n                            : MomentUtils.parseDate()))\n                        : // tslint:disable-next-line:no-unused-expression\n                            null;\n            }\n            // Add formControl to the form group with the generated validation rules\n            const control = builder.control({\n                value: config.value,\n                disabled: config.disabled,\n            }, asyncValidators.length > 0 || config.type === InputTypes.DATE_INPUT\n                ? {\n                    validators: Validators.compose(validators),\n                    updateOn: \"blur\",\n                    asyncValidators,\n                }\n                : {\n                    validators: Validators.compose(validators),\n                });\n            group.addControl(config.formControlName, control\n            // Add other necessary validators\n            );\n        }\n        else {\n            // Build list of checkboxes\n            const array = new FormArray([]);\n            observableOf(config.items)\n                .pipe(tap((items) => {\n                items.map((it, index) => {\n                    // Added validation rule to checkbox array\n                    array.push(builder.control(it.checked));\n                });\n            }))\n                .subscribe();\n            // Add FormArray control to the formGroup\n            if (config.rules && config.rules.isRequired) {\n                array.setValidators(Validators.required);\n            }\n            group.addControl(config.formControlName, array);\n        }\n    });\n    return group;\n};\n/**\n * @description Build an angular form group from a dynamic form instance\n *\n * @param builder\n * @param form\n */\nexport const createAngularAbstractControl = (builder, form) => {\n    return form\n        ? ComponentReactiveFormHelpers.buildFormGroupFromInputConfig(builder, [\n            ...form === null || form === void 0 ? void 0 : form.controlConfigs,\n        ])\n        : undefined;\n};\n"]},"metadata":{},"sourceType":"module"}